#include <iostream>
#include <vector>

#include "Point.h"
#include "LineSegment.h"

class FastCollinearPoints {
public:
    FastCollinearPoints(std::vector<Point> points)
    {
        std::vector<Point> internalPoints = std::vector<Point>(points.size());
        for (int i = 0; i < points.size(); i++) {
            for (int j = i + 1; j < points.size(); j++) {
                if (points[i] == points[j]) {
                    std::cout << "duplicate  point" << std::endl;
                    exit(0);
                }
            }
            internalPoints[i] = points[i];
        }

        std::sort(internalPoints.begin(), internalPoints.end());

        int length = internalPoints.size();
        for (int i = 0; i < length - 1; i++) {
            Point origPoint = internalPoints[i];
            int otherPointsN = 0;
            std::vector<Point> otherPoints = std::vector<Point>(length - 1);

            for (int j = 0; j < length; j++) {
                if (i != j)
                    otherPoints[otherPointsN++] = internalPoints[j];
            }
            SlotComp slopOrder = SlotComp(internalPoints[i]);
            //Arrays.sort(otherPoints, internalPoints[i].slopeOrder());
            {
                std::cout << "before sort" << std::endl;
                for (auto iter : otherPoints) {
                    std::cout << iter << " ";
                }
                std::cout << std::endl;
            }
            std::sort(otherPoints.begin(), otherPoints.end(), slopOrder);
            {
                std::cout << "after sort" << std::endl;
                for (auto iter : otherPoints) {
                    std::cout << iter << " ";
                }
                std::cout << std::endl;
            }
            int count = 0;
            Point* min;
            Point* max;
            for (int j = 0; j < otherPointsN - 1; j++) {
                if (compare_float(origPoint.slopeTo(otherPoints[j]),
                                   origPoint.slopeTo(otherPoints[j + 1])) == 0) {
                    count++;
                    if (min == nullptr && max == nullptr) {
                        if (origPoint > otherPoints[j]) {
                            *max = origPoint;
                            *min = otherPoints[j];
                        } else {
                            *max = otherPoints[j];
                            *min = origPoint;
                        }
                    }
                    if (otherPoints[j + 1] < *min) {
                        *min = otherPoints[j + 1];
                    }
                    if (otherPoints[j + 1] > *max) {
                        *max = otherPoints[j + 1];
                    }
                    if (j == otherPointsN - 2 && count >= 2 && origPoint == *min) {
                        segments.push_back(LineSegment(*min, *max));
                    }
                } else {
                    if (count >= 2 && origPoint == *min) {
                        segments.push_back(LineSegment(*min, *max));
                    }
                    count = 0;
                    max = nullptr;
                    min = nullptr;
                }
            }
        }
    }

    int numberOfSegments() { return segments.size(); }

    std::vector<LineSegment>& getSegments() { return segments; }

private:
    bool compare_float(double x, double y) {
        return std::abs(x - y) < EPSILON;
    }

private:
    const double EPSILON = 0.0000001f;
    std::vector<LineSegment> segments;
};

int main(int argc, char const *argv[])
{
    int num;
    std::cin >> num;
    std::vector<Point> points;
    Point point;

    while (std::cin >> point) {
        points.push_back(point);
        //std::cout << "push " << point << " in" << std::endl;
    }

    FastCollinearPoints fcp = FastCollinearPoints(points);

    for (auto iter : fcp.getSegments()) {
        std::cout << iter << std::endl;
    }

    return 0;
}